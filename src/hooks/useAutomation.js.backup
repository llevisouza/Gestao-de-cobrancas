// src/hooks/useAutomation.js - VERSÃO CORRIGIDA
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:3001/api';

export const useAutomation = () => {
  const [isRunning, setIsRunning] = useState(null); // null = não carregado ainda
  const [config, setConfig] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [stats, setStats] = useState({});
  const [logs, setLogs] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState(null);

  // ✅ Função para buscar status com retry e melhor error handling
  const fetchStatus = useCallback(async (retries = 3, showLoading = true) => {
    if (showLoading) setLoading(true);
    
    for (let i = 0; i < retries; i++) {
      try {
        console.log(`📡 [useAutomation] Buscando status (tentativa ${i + 1})...`);
        
        const response = await axios.get(`${API_BASE_URL}/automation/status`, {
          timeout: 10000,
          headers: {
            'Content-Type': 'application/json'
          }
        });

        console.log('✅ [useAutomation] Status recebido:', response.data);
        
        // ✅ Atualizar estados baseado na resposta
        setIsRunning(response.data.isRunning);
        setConfig(response.data.config || {});
        setStats(response.data.stats || {});
        setError(null);
        
        if (showLoading) setLoading(false);
        return response.data;
        
      } catch (err) {
        console.error(`❌ [useAutomation] Erro na tentativa ${i + 1}:`, err.message);
        
        if (i === retries - 1) {
          // Última tentativa falhou
          setError(`Falha ao conectar: ${err.message}`);
          setIsRunning(false); // Assumir parado se não conseguir conectar
          if (showLoading) setLoading(false);
          return { isRunning: false, error: err.message };
        } else {
          // Tentar novamente após delay
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }
  }, []);

  // ✅ Iniciar automação com feedback imediato
  const startAutomation = useCallback(async () => {
    console.log('🚀 [useAutomation] Iniciando automação...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/start`, {}, {
        timeout: 30000, // 30 segundos para dar tempo
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('✅ [useAutomation] Resposta do start:', response.data);
      
      if (response.data.success) {
        // ✅ Atualizar estado imediatamente
        setIsRunning(true);
        
        // ✅ Verificar status após 2 segundos para confirmar
        setTimeout(() => {
          fetchStatus(1, false); // 1 tentativa, sem loading
        }, 2000);
        
        return { success: true, message: 'Automação iniciada!' };
      } else {
        throw new Error(response.data.error || 'Falha ao iniciar');
      }
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro ao iniciar:', err.message);
      setError(`Erro ao iniciar: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // ✅ Parar automação com feedback imediato
  const stopAutomation = useCallback(async () => {
    console.log('🛑 [useAutomation] Parando automação...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/stop`, {}, {
        timeout: 15000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('✅ [useAutomation] Resposta do stop:', response.data);
      
      if (response.data.success) {
        // ✅ Atualizar estado imediatamente
        setIsRunning(false);
        
        // ✅ Verificar status após 1 segundo para confirmar
        setTimeout(() => {
          fetchStatus(1, false);
        }, 1000);
        
        return { success: true, message: 'Automação parada!' };
      } else {
        throw new Error(response.data.error || 'Falha ao parar');
      }
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro ao parar:', err.message);
      setError(`Erro ao parar: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // ✅ Executar ciclo manual
  const runManualCycle = useCallback(async () => {
    console.log('🔄 [useAutomation] Executando ciclo manual...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/manual-cycle`, {}, {
        timeout: 30000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('✅ [useAutomation] Resultado do ciclo manual:', response.data);
      
      // ✅ Atualizar stats após ciclo manual
      setTimeout(() => {
        fetchStatus(1, false);
      }, 1000);
      
      return response.data;
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro no ciclo manual:', err.message);
      setError(`Erro no ciclo manual: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // ✅ Atualizar configuração
  const updateConfig = useCallback(async (newConfig) => {
    console.log('⚙️ [useAutomation] Atualizando configuração:', newConfig);
    setLoading(true);
    
    try {
      const response = await axios.put(`${API_BASE_URL}/automation/config`, {
        config: newConfig
      }, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('✅ [useAutomation] Configuração atualizada:', response.data);
      
      if (response.data.success) {
        setConfig(response.data.config || newConfig);
        return { success: true, config: response.data.config };
      }
      
      return response.data;
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro ao atualizar config:', err.message);
      setError(`Erro na configuração: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, []);

  // ✅ Testar conexões
  const testConnections = useCallback(async () => {
    console.log('🔍 [useAutomation] Testando conexões...');
    setLoading(true);
    
    try {
      const response = await axios.get(`${API_BASE_URL}/health`, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('✅ [useAutomation] Health check:', response.data);
      setConnectionStatus(response.data.health);
      return response.data;
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro no teste:', err.message);
      setError(`Erro no teste: ${err.message}`);
      setConnectionStatus({ database: false, whatsapp: { connected: false }, error: err.message });
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, []);

  // ✅ Buscar estatísticas
  const getAutomationStats = useCallback(async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/automation/performance?days=7`, {
        timeout: 10000
      });
      
      console.log('📊 [useAutomation] Stats recebidas:', response.data);
      setStats(response.data.report || {});
      return response.data;
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro nas stats:', err.message);
      return { error: err.message };
    }
  }, []);

  // ✅ Buscar logs
  const getLogs = useCallback(async (limit = 50) => {
    try {
      const response = await axios.get(`${API_BASE_URL}/automation/logs?limit=${limit}`, {
        timeout: 10000
      });
      
      console.log('📜 [useAutomation] Logs recebidos:', response.data);
      setLogs(response.data.logs || []);
      return response.data.logs || [];
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro nos logs:', err.message);
      return [];
    }
  }, []);

  // ✅ Reset completo
  const resetAutomation = useCallback(async () => {
    console.log('🔄 [useAutomation] Fazendo reset...');
    setLoading(true);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/reset`, {}, {
        timeout: 15000
      });
      
      console.log('✅ [useAutomation] Reset concluído:', response.data);
      
      // ✅ Limpar estados locais
      setIsRunning(false);
      setStats({});
      setLogs([]);
      setError(null);
      
      // ✅ Recarregar status
      setTimeout(() => {
        fetchStatus();
      }, 1000);
      
      return response.data;
      
    } catch (err) {
      console.error('❌ [useAutomation] Erro no reset:', err.message);
      setError(`Erro no reset: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // ✅ Carregar status inicial
  useEffect(() => {
    console.log('🛠️ [useAutomation] Hook inicializado, carregando status...');
    fetchStatus();
  }, [fetchStatus]);

  // ✅ Polling periódico para manter sincronizado (a cada 30 segundos)
  useEffect(() => {
    const interval = setInterval(() => {
      if (!loading) {
        console.log('🔄 [useAutomation] Polling status...');
        fetchStatus(1, false); // 1 tentativa, sem loading
      }
    }, 30000); // 30 segundos

    return () => clearInterval(interval);
  }, [fetchStatus, loading]);

  // ✅ SSE para updates em tempo real (se disponível)
  useEffect(() => {
    console.log('📡 [useAutomation] Tentando conectar SSE...');
    
    let eventSource;
    let reconnectTimeout;
    
    const connectSSE = () => {
      try {
        eventSource = new EventSource(`${API_BASE_URL}/automation/events`);
        
        eventSource.onopen = () => {
          console.log('✅ [useAutomation] SSE conectado');
          setError(null);
        };
        
        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log('📨 [useAutomation] SSE update:', data);
            
            // ✅ Atualizar estados com dados do SSE
            if (data.isRunning !== undefined) {
              setIsRunning(data.isRunning);
            }
            if (data.config) {
              setConfig(data.config);
            }
            if (data.stats) {
              setStats(data.stats);
            }
            
            setLoading(false);
            setError(null);
            
          } catch (parseError) {
            console.error('❌ [useAutomation] Erro ao processar SSE:', parseError);
          }
        };
        
        eventSource.onerror = (error) => {
          console.error('❌ [useAutomation] Erro SSE:', error);
          eventSource.close();
          
          // ✅ Reconectar após 5 segundos
          reconnectTimeout = setTimeout(() => {
            console.log('🔄 [useAutomation] Tentando reconectar SSE...');
            connectSSE();
          }, 5000);
        };
        
      } catch (error) {
        console.error('❌ [useAutomation] Erro ao conectar SSE:', error);
      }
    };
    
    // Conectar SSE
    connectSSE();
    
    // ✅ Cleanup
    return () => {
      if (eventSource) {
        console.log('🛑 [useAutomation] Fechando SSE');
        eventSource.close();
      }
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
    };
  }, []);

  return {
    // ✅ Estados
    isRunning,
    config,
    loading,
    error,
    stats,
    logs,
    connectionStatus,

    // ✅ Ações principais
    startAutomation,
    stopAutomation,
    runManualCycle,
    updateConfig,
    resetAutomation,

    // ✅ Informações
    getAutomationStats,
    getLogs,
    testConnections,
    getStatus: fetchStatus,

    // ✅ Utilitários
    isConnected: connectionStatus?.database && connectionStatus?.whatsapp?.connected,
    hasError: !!error,
    isLoading: loading,
    canStart: !loading && !isRunning,
    canStop: !loading && isRunning
  };
};
