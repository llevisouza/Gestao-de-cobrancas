{"ast":null,"code":"// src/services/firestore.js\nimport { collection, doc, addDoc, updateDoc, deleteDoc, getDocs, getDoc, onSnapshot, query, orderBy, where, Timestamp, writeBatch } from 'firebase/firestore';\nimport { db } from './firebase';\n\n// Constantes das coleções\nconst COLLECTIONS = {\n  CLIENTS: 'clients',\n  SUBSCRIPTIONS: 'subscriptions',\n  INVOICES: 'invoices'\n};\n\n// =================== CLIENTES ===================\n\n/**\r\n * Criar um novo cliente\r\n * @param {Object} clientData - Dados do cliente\r\n * @returns {Promise<string>} - ID do cliente criado\r\n */\nexport const createClient = async clientData => {\n  try {\n    const docRef = await addDoc(collection(db, COLLECTIONS.CLIENTS), {\n      ...clientData,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Cliente criado:', docRef.id);\n    return docRef.id;\n  } catch (error) {\n    console.error('❌ Erro ao criar cliente:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Atualizar cliente existente\r\n * @param {string} clientId - ID do cliente\r\n * @param {Object} clientData - Dados para atualizar\r\n */\nexport const updateClient = async (clientId, clientData) => {\n  try {\n    const clientRef = doc(db, COLLECTIONS.CLIENTS, clientId);\n    await updateDoc(clientRef, {\n      ...clientData,\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Cliente atualizado:', clientId);\n  } catch (error) {\n    console.error('❌ Erro ao atualizar cliente:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Deletar cliente\r\n * @param {string} clientId - ID do cliente\r\n */\nexport const deleteClient = async clientId => {\n  try {\n    // Verificar se há assinaturas ativas\n    const subscriptionsQuery = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('clientId', '==', clientId), where('status', '==', 'active'));\n    const activeSubscriptions = await getDocs(subscriptionsQuery);\n    if (!activeSubscriptions.empty) {\n      throw new Error('Não é possível deletar cliente com assinaturas ativas');\n    }\n    await deleteDoc(doc(db, COLLECTIONS.CLIENTS, clientId));\n    console.log('✅ Cliente deletado:', clientId);\n  } catch (error) {\n    console.error('❌ Erro ao deletar cliente:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Buscar todos os clientes\r\n * @returns {Promise<Array>} - Lista de clientes\r\n */\nexport const getAllClients = async () => {\n  try {\n    const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\n    const querySnapshot = await getDocs(q);\n    const clients = [];\n    querySnapshot.forEach(doc => {\n      clients.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    return clients;\n  } catch (error) {\n    console.error('❌ Erro ao buscar clientes:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Subscrever para mudanças nos clientes\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\nexport const subscribeToClients = callback => {\n  const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\n  return onSnapshot(q, querySnapshot => {\n    const clients = [];\n    querySnapshot.forEach(doc => {\n      clients.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    callback(clients);\n  }, error => {\n    console.error('❌ Erro na subscrição de clientes:', error);\n  });\n};\n\n// =================== ASSINATURAS ===================\n\n/**\r\n * Criar nova assinatura\r\n * @param {Object} subscriptionData - Dados da assinatura\r\n * @returns {Promise<string>} - ID da assinatura criada\r\n */\nexport const createSubscription = async subscriptionData => {\n  try {\n    // Calcular próxima data de cobrança\n    const nextBillingDate = calculateNextBillingDate(subscriptionData.startDate, subscriptionData.billingCycle);\n    const docRef = await addDoc(collection(db, COLLECTIONS.SUBSCRIPTIONS), {\n      ...subscriptionData,\n      nextBillingDate: Timestamp.fromDate(nextBillingDate),\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Assinatura criada:', docRef.id);\n    return docRef.id;\n  } catch (error) {\n    console.error('❌ Erro ao criar assinatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Atualizar assinatura\r\n * @param {string} subscriptionId - ID da assinatura\r\n * @param {Object} subscriptionData - Dados para atualizar\r\n */\nexport const updateSubscription = async (subscriptionId, subscriptionData) => {\n  try {\n    const subscriptionRef = doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId);\n    await updateDoc(subscriptionRef, {\n      ...subscriptionData,\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Assinatura atualizada:', subscriptionId);\n  } catch (error) {\n    console.error('❌ Erro ao atualizar assinatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Deletar assinatura\r\n * @param {string} subscriptionId - ID da assinatura\r\n */\nexport const deleteSubscription = async subscriptionId => {\n  try {\n    await deleteDoc(doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId));\n    console.log('✅ Assinatura deletada:', subscriptionId);\n  } catch (error) {\n    console.error('❌ Erro ao deletar assinatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Buscar assinaturas por cliente\r\n * @param {string} clientId - ID do cliente\r\n * @returns {Promise<Array>} - Lista de assinaturas do cliente\r\n */\nexport const getSubscriptionsByClient = async clientId => {\n  try {\n    const q = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('clientId', '==', clientId), orderBy('createdAt', 'desc'));\n    const querySnapshot = await getDocs(q);\n    const subscriptions = [];\n    querySnapshot.forEach(doc => {\n      subscriptions.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    return subscriptions;\n  } catch (error) {\n    console.error('❌ Erro ao buscar assinaturas:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Subscrever para mudanças nas assinaturas\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\nexport const subscribeToSubscriptions = callback => {\n  const q = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), orderBy('createdAt', 'desc'));\n  return onSnapshot(q, querySnapshot => {\n    const subscriptions = [];\n    querySnapshot.forEach(doc => {\n      subscriptions.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    callback(subscriptions);\n  });\n};\n\n// =================== FATURAS ===================\n\n/**\r\n * Criar nova fatura\r\n * @param {Object} invoiceData - Dados da fatura\r\n * @returns {Promise<string>} - ID da fatura criada\r\n */\nexport const createInvoice = async invoiceData => {\n  try {\n    const docRef = await addDoc(collection(db, COLLECTIONS.INVOICES), {\n      ...invoiceData,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Fatura criada:', docRef.id);\n    return docRef.id;\n  } catch (error) {\n    console.error('❌ Erro ao criar fatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Atualizar fatura\r\n * @param {string} invoiceId - ID da fatura\r\n * @param {Object} invoiceData - Dados para atualizar\r\n */\nexport const updateInvoice = async (invoiceId, invoiceData) => {\n  try {\n    const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\n    await updateDoc(invoiceRef, {\n      ...invoiceData,\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Fatura atualizada:', invoiceId);\n  } catch (error) {\n    console.error('❌ Erro ao atualizar fatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Deletar fatura\r\n * @param {string} invoiceId - ID da fatura\r\n */\nexport const deleteInvoice = async invoiceId => {\n  try {\n    await deleteDoc(doc(db, COLLECTIONS.INVOICES, invoiceId));\n    console.log('✅ Fatura deletada:', invoiceId);\n  } catch (error) {\n    console.error('❌ Erro ao deletar fatura:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Marcar fatura como paga\r\n * @param {string} invoiceId - ID da fatura\r\n */\nexport const markInvoiceAsPaid = async invoiceId => {\n  try {\n    const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\n    await updateDoc(invoiceRef, {\n      status: 'paid',\n      paidAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    });\n    console.log('✅ Fatura marcada como paga:', invoiceId);\n  } catch (error) {\n    console.error('❌ Erro ao marcar fatura como paga:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Subscrever para mudanças nas faturas\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\nexport const subscribeToInvoices = callback => {\n  const q = query(collection(db, COLLECTIONS.INVOICES), orderBy('dueDate', 'desc'));\n  return onSnapshot(q, querySnapshot => {\n    const invoices = [];\n    querySnapshot.forEach(doc => {\n      invoices.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    callback(invoices);\n  });\n};\n\n/**\r\n * Buscar faturas por período\r\n * @param {Date} startDate - Data de início\r\n * @param {Date} endDate - Data de fim\r\n * @returns {Promise<Array>} - Lista de faturas no período\r\n */\nexport const getInvoicesByPeriod = async (startDate, endDate) => {\n  try {\n    const q = query(collection(db, COLLECTIONS.INVOICES), where('dueDate', '>=', Timestamp.fromDate(startDate)), where('dueDate', '<=', Timestamp.fromDate(endDate)), orderBy('dueDate', 'desc'));\n    const querySnapshot = await getDocs(q);\n    const invoices = [];\n    querySnapshot.forEach(doc => {\n      invoices.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    return invoices;\n  } catch (error) {\n    console.error('❌ Erro ao buscar faturas por período:', error);\n    throw error;\n  }\n};\n\n// =================== FUNÇÕES AUXILIARES ===================\n\n/**\r\n * Calcular próxima data de cobrança baseada no ciclo\r\n * @param {Date} startDate - Data de início\r\n * @param {string} billingCycle - Ciclo de cobrança\r\n * @returns {Date} - Próxima data de cobrança\r\n */\nconst calculateNextBillingDate = (startDate, billingCycle) => {\n  const date = new Date(startDate);\n  switch (billingCycle) {\n    case 'monthly':\n      date.setMonth(date.getMonth() + 1);\n      break;\n    case 'quarterly':\n      date.setMonth(date.getMonth() + 3);\n      break;\n    case 'semiannual':\n      date.setMonth(date.getMonth() + 6);\n      break;\n    case 'annual':\n      date.setFullYear(date.getFullYear() + 1);\n      break;\n    default:\n      date.setMonth(date.getMonth() + 1);\n  }\n  return date;\n};\n\n/**\r\n * Gerar faturas para assinaturas do mês\r\n * @param {number} month - Mês (0-11)\r\n * @param {number} year - Ano\r\n */\nexport const generateInvoicesForMonth = async (month, year) => {\n  try {\n    console.log(`🔄 Gerando faturas para ${month + 1}/${year}`);\n\n    // Buscar assinaturas ativas\n    const subscriptionsQuery = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('status', '==', 'active'));\n    const subscriptionsSnapshot = await getDocs(subscriptionsQuery);\n    const batch = writeBatch(db);\n    let invoicesCreated = 0;\n    for (const subscriptionDoc of subscriptionsSnapshot.docs) {\n      const subscription = {\n        id: subscriptionDoc.id,\n        ...subscriptionDoc.data()\n      };\n\n      // Verificar se deve gerar fatura neste mês\n      if (shouldGenerateInvoiceForMonth(subscription, month, year)) {\n        // Verificar se fatura já existe\n        const existingInvoiceQuery = query(collection(db, COLLECTIONS.INVOICES), where('subscriptionId', '==', subscription.id), where('month', '==', month), where('year', '==', year));\n        const existingInvoices = await getDocs(existingInvoiceQuery);\n        if (existingInvoices.empty) {\n          // Criar nova fatura\n          const dueDate = new Date(year, month, subscription.billingDay || 5);\n          const invoiceRef = doc(collection(db, COLLECTIONS.INVOICES));\n          batch.set(invoiceRef, {\n            clientId: subscription.clientId,\n            subscriptionId: subscription.id,\n            amount: subscription.amount,\n            description: subscription.description,\n            dueDate: Timestamp.fromDate(dueDate),\n            status: 'pending',\n            month,\n            year,\n            createdAt: Timestamp.now(),\n            updatedAt: Timestamp.now()\n          });\n          invoicesCreated++;\n        }\n      }\n    }\n    if (invoicesCreated > 0) {\n      await batch.commit();\n      console.log(`✅ ${invoicesCreated} faturas geradas com sucesso`);\n    } else {\n      console.log('ℹ️ Nenhuma fatura nova para gerar');\n    }\n    return invoicesCreated;\n  } catch (error) {\n    console.error('❌ Erro ao gerar faturas:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Verificar se deve gerar fatura para o mês\r\n * @param {Object} subscription - Dados da assinatura\r\n * @param {number} month - Mês (0-11)\r\n * @param {number} year - Ano\r\n * @returns {boolean}\r\n */\nconst shouldGenerateInvoiceForMonth = (subscription, month, year) => {\n  const startDate = subscription.startDate.toDate();\n  const currentDate = new Date(year, month, 1);\n\n  // Assinatura deve ter iniciado\n  if (startDate > currentDate) {\n    return false;\n  }\n\n  // Verificar ciclo de cobrança\n  const startMonth = startDate.getMonth();\n  const startYear = startDate.getFullYear();\n  switch (subscription.billingCycle) {\n    case 'monthly':\n      return true;\n    case 'quarterly':\n      return (month - startMonth) % 3 === 0;\n    case 'semiannual':\n      return (month - startMonth) % 6 === 0;\n    case 'annual':\n      return month === startMonth;\n    default:\n      return true;\n  }\n};\n\n// =================== DADOS DE EXEMPLO ===================\n\n/**\r\n * Criar dados de exemplo para teste\r\n */\nexport const createSampleData = async () => {\n  try {\n    console.log('🔄 Criando dados de exemplo...');\n\n    // Criar clientes de exemplo\n    const clients = [{\n      name: 'João Silva',\n      email: 'joao@email.com',\n      phone: '(11) 99999-1111',\n      company: 'Silva & Associados',\n      address: 'Rua das Flores, 123'\n    }, {\n      name: 'Maria Santos',\n      email: 'maria@email.com',\n      phone: '(11) 99999-2222',\n      company: 'Santos Ltda',\n      address: 'Av. Principal, 456'\n    }, {\n      name: 'Pedro Oliveira',\n      email: 'pedro@email.com',\n      phone: '(11) 99999-3333',\n      company: 'Oliveira Corp',\n      address: 'Rua do Comércio, 789'\n    }];\n    const clientIds = [];\n    for (const client of clients) {\n      const clientId = await createClient(client);\n      clientIds.push(clientId);\n    }\n\n    // Criar assinaturas de exemplo\n    const subscriptions = [{\n      clientId: clientIds[0],\n      service: 'Website Básico',\n      description: 'Manutenção mensal do website',\n      amount: 300,\n      billingCycle: 'monthly',\n      startDate: new Date('2024-01-01'),\n      status: 'active',\n      billingDay: 5\n    }, {\n      clientId: clientIds[1],\n      service: 'SEO Premium',\n      description: 'Otimização SEO completa',\n      amount: 800,\n      billingCycle: 'monthly',\n      startDate: new Date('2024-02-01'),\n      status: 'active',\n      billingDay: 10\n    }, {\n      clientId: clientIds[2],\n      service: 'Consultoria Anual',\n      description: 'Consultoria estratégica anual',\n      amount: 5000,\n      billingCycle: 'annual',\n      startDate: new Date('2024-01-15'),\n      status: 'active',\n      billingDay: 15\n    }];\n    const subscriptionIds = [];\n    for (const subscription of subscriptions) {\n      const subscriptionId = await createSubscription(subscription);\n      subscriptionIds.push(subscriptionId);\n    }\n\n    // Criar algumas faturas de exemplo\n    const invoices = [{\n      clientId: clientIds[0],\n      subscriptionId: subscriptionIds[0],\n      amount: 300,\n      description: 'Website Básico - Janeiro 2024',\n      dueDate: new Date('2024-01-05'),\n      status: 'paid',\n      month: 0,\n      year: 2024,\n      paidAt: new Date('2024-01-03')\n    }, {\n      clientId: clientIds[1],\n      subscriptionId: subscriptionIds[1],\n      amount: 800,\n      description: 'SEO Premium - Fevereiro 2024',\n      dueDate: new Date('2024-02-10'),\n      status: 'pending',\n      month: 1,\n      year: 2024\n    }];\n    for (const invoice of invoices) {\n      await createInvoice(invoice);\n    }\n    console.log('✅ Dados de exemplo criados com sucesso!');\n    return {\n      clients: clientIds.length,\n      subscriptions: subscriptionIds.length,\n      invoices: invoices.length\n    };\n  } catch (error) {\n    console.error('❌ Erro ao criar dados de exemplo:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["collection","doc","addDoc","updateDoc","deleteDoc","getDocs","getDoc","onSnapshot","query","orderBy","where","Timestamp","writeBatch","db","COLLECTIONS","CLIENTS","SUBSCRIPTIONS","INVOICES","createClient","clientData","docRef","createdAt","now","updatedAt","console","log","id","error","updateClient","clientId","clientRef","deleteClient","subscriptionsQuery","activeSubscriptions","empty","Error","getAllClients","q","querySnapshot","clients","forEach","push","data","subscribeToClients","callback","createSubscription","subscriptionData","nextBillingDate","calculateNextBillingDate","startDate","billingCycle","fromDate","updateSubscription","subscriptionId","subscriptionRef","deleteSubscription","getSubscriptionsByClient","subscriptions","subscribeToSubscriptions","createInvoice","invoiceData","updateInvoice","invoiceId","invoiceRef","deleteInvoice","markInvoiceAsPaid","status","paidAt","subscribeToInvoices","invoices","getInvoicesByPeriod","endDate","date","Date","setMonth","getMonth","setFullYear","getFullYear","generateInvoicesForMonth","month","year","subscriptionsSnapshot","batch","invoicesCreated","subscriptionDoc","docs","subscription","shouldGenerateInvoiceForMonth","existingInvoiceQuery","existingInvoices","dueDate","billingDay","set","amount","description","commit","toDate","currentDate","startMonth","startYear","createSampleData","name","email","phone","company","address","clientIds","client","service","subscriptionIds","invoice","length"],"sources":["C:/Users/LEVI/Desktop/Gestao-de-cobrancas/src/hooks/useFirestore.js"],"sourcesContent":["// src/services/firestore.js\r\nimport { \r\n  collection, \r\n  doc, \r\n  addDoc, \r\n  updateDoc, \r\n  deleteDoc, \r\n  getDocs, \r\n  getDoc,\r\n  onSnapshot,\r\n  query,\r\n  orderBy,\r\n  where,\r\n  Timestamp,\r\n  writeBatch\r\n} from 'firebase/firestore';\r\nimport { db } from './firebase';\r\n\r\n// Constantes das coleções\r\nconst COLLECTIONS = {\r\n  CLIENTS: 'clients',\r\n  SUBSCRIPTIONS: 'subscriptions',\r\n  INVOICES: 'invoices'\r\n};\r\n\r\n// =================== CLIENTES ===================\r\n\r\n/**\r\n * Criar um novo cliente\r\n * @param {Object} clientData - Dados do cliente\r\n * @returns {Promise<string>} - ID do cliente criado\r\n */\r\nexport const createClient = async (clientData) => {\r\n  try {\r\n    const docRef = await addDoc(collection(db, COLLECTIONS.CLIENTS), {\r\n      ...clientData,\r\n      createdAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    console.log('✅ Cliente criado:', docRef.id);\r\n    return docRef.id;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao criar cliente:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Atualizar cliente existente\r\n * @param {string} clientId - ID do cliente\r\n * @param {Object} clientData - Dados para atualizar\r\n */\r\nexport const updateClient = async (clientId, clientData) => {\r\n  try {\r\n    const clientRef = doc(db, COLLECTIONS.CLIENTS, clientId);\r\n    await updateDoc(clientRef, {\r\n      ...clientData,\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    console.log('✅ Cliente atualizado:', clientId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao atualizar cliente:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Deletar cliente\r\n * @param {string} clientId - ID do cliente\r\n */\r\nexport const deleteClient = async (clientId) => {\r\n  try {\r\n    // Verificar se há assinaturas ativas\r\n    const subscriptionsQuery = query(\r\n      collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n      where('clientId', '==', clientId),\r\n      where('status', '==', 'active')\r\n    );\r\n    const activeSubscriptions = await getDocs(subscriptionsQuery);\r\n    \r\n    if (!activeSubscriptions.empty) {\r\n      throw new Error('Não é possível deletar cliente com assinaturas ativas');\r\n    }\r\n\r\n    await deleteDoc(doc(db, COLLECTIONS.CLIENTS, clientId));\r\n    console.log('✅ Cliente deletado:', clientId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao deletar cliente:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Buscar todos os clientes\r\n * @returns {Promise<Array>} - Lista de clientes\r\n */\r\nexport const getAllClients = async () => {\r\n  try {\r\n    const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\r\n    const querySnapshot = await getDocs(q);\r\n    const clients = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      clients.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    \r\n    return clients;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao buscar clientes:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Subscrever para mudanças nos clientes\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\r\nexport const subscribeToClients = (callback) => {\r\n  const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\r\n  \r\n  return onSnapshot(q, (querySnapshot) => {\r\n    const clients = [];\r\n    querySnapshot.forEach((doc) => {\r\n      clients.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    callback(clients);\r\n  }, (error) => {\r\n    console.error('❌ Erro na subscrição de clientes:', error);\r\n  });\r\n};\r\n\r\n// =================== ASSINATURAS ===================\r\n\r\n/**\r\n * Criar nova assinatura\r\n * @param {Object} subscriptionData - Dados da assinatura\r\n * @returns {Promise<string>} - ID da assinatura criada\r\n */\r\nexport const createSubscription = async (subscriptionData) => {\r\n  try {\r\n    // Calcular próxima data de cobrança\r\n    const nextBillingDate = calculateNextBillingDate(\r\n      subscriptionData.startDate,\r\n      subscriptionData.billingCycle\r\n    );\r\n\r\n    const docRef = await addDoc(collection(db, COLLECTIONS.SUBSCRIPTIONS), {\r\n      ...subscriptionData,\r\n      nextBillingDate: Timestamp.fromDate(nextBillingDate),\r\n      createdAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    \r\n    console.log('✅ Assinatura criada:', docRef.id);\r\n    return docRef.id;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao criar assinatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Atualizar assinatura\r\n * @param {string} subscriptionId - ID da assinatura\r\n * @param {Object} subscriptionData - Dados para atualizar\r\n */\r\nexport const updateSubscription = async (subscriptionId, subscriptionData) => {\r\n  try {\r\n    const subscriptionRef = doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId);\r\n    await updateDoc(subscriptionRef, {\r\n      ...subscriptionData,\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    console.log('✅ Assinatura atualizada:', subscriptionId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao atualizar assinatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Deletar assinatura\r\n * @param {string} subscriptionId - ID da assinatura\r\n */\r\nexport const deleteSubscription = async (subscriptionId) => {\r\n  try {\r\n    await deleteDoc(doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId));\r\n    console.log('✅ Assinatura deletada:', subscriptionId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao deletar assinatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Buscar assinaturas por cliente\r\n * @param {string} clientId - ID do cliente\r\n * @returns {Promise<Array>} - Lista de assinaturas do cliente\r\n */\r\nexport const getSubscriptionsByClient = async (clientId) => {\r\n  try {\r\n    const q = query(\r\n      collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n      where('clientId', '==', clientId),\r\n      orderBy('createdAt', 'desc')\r\n    );\r\n    const querySnapshot = await getDocs(q);\r\n    const subscriptions = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      subscriptions.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    \r\n    return subscriptions;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao buscar assinaturas:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Subscrever para mudanças nas assinaturas\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\r\nexport const subscribeToSubscriptions = (callback) => {\r\n  const q = query(\r\n    collection(db, COLLECTIONS.SUBSCRIPTIONS), \r\n    orderBy('createdAt', 'desc')\r\n  );\r\n  \r\n  return onSnapshot(q, (querySnapshot) => {\r\n    const subscriptions = [];\r\n    querySnapshot.forEach((doc) => {\r\n      subscriptions.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    callback(subscriptions);\r\n  });\r\n};\r\n\r\n// =================== FATURAS ===================\r\n\r\n/**\r\n * Criar nova fatura\r\n * @param {Object} invoiceData - Dados da fatura\r\n * @returns {Promise<string>} - ID da fatura criada\r\n */\r\nexport const createInvoice = async (invoiceData) => {\r\n  try {\r\n    const docRef = await addDoc(collection(db, COLLECTIONS.INVOICES), {\r\n      ...invoiceData,\r\n      createdAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    \r\n    console.log('✅ Fatura criada:', docRef.id);\r\n    return docRef.id;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao criar fatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Atualizar fatura\r\n * @param {string} invoiceId - ID da fatura\r\n * @param {Object} invoiceData - Dados para atualizar\r\n */\r\nexport const updateInvoice = async (invoiceId, invoiceData) => {\r\n  try {\r\n    const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\r\n    await updateDoc(invoiceRef, {\r\n      ...invoiceData,\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    console.log('✅ Fatura atualizada:', invoiceId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao atualizar fatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Deletar fatura\r\n * @param {string} invoiceId - ID da fatura\r\n */\r\nexport const deleteInvoice = async (invoiceId) => {\r\n  try {\r\n    await deleteDoc(doc(db, COLLECTIONS.INVOICES, invoiceId));\r\n    console.log('✅ Fatura deletada:', invoiceId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao deletar fatura:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Marcar fatura como paga\r\n * @param {string} invoiceId - ID da fatura\r\n */\r\nexport const markInvoiceAsPaid = async (invoiceId) => {\r\n  try {\r\n    const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\r\n    await updateDoc(invoiceRef, {\r\n      status: 'paid',\r\n      paidAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now()\r\n    });\r\n    console.log('✅ Fatura marcada como paga:', invoiceId);\r\n  } catch (error) {\r\n    console.error('❌ Erro ao marcar fatura como paga:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Subscrever para mudanças nas faturas\r\n * @param {Function} callback - Função callback para receber atualizações\r\n * @returns {Function} - Função de unsubscribe\r\n */\r\nexport const subscribeToInvoices = (callback) => {\r\n  const q = query(\r\n    collection(db, COLLECTIONS.INVOICES), \r\n    orderBy('dueDate', 'desc')\r\n  );\r\n  \r\n  return onSnapshot(q, (querySnapshot) => {\r\n    const invoices = [];\r\n    querySnapshot.forEach((doc) => {\r\n      invoices.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    callback(invoices);\r\n  });\r\n};\r\n\r\n/**\r\n * Buscar faturas por período\r\n * @param {Date} startDate - Data de início\r\n * @param {Date} endDate - Data de fim\r\n * @returns {Promise<Array>} - Lista de faturas no período\r\n */\r\nexport const getInvoicesByPeriod = async (startDate, endDate) => {\r\n  try {\r\n    const q = query(\r\n      collection(db, COLLECTIONS.INVOICES),\r\n      where('dueDate', '>=', Timestamp.fromDate(startDate)),\r\n      where('dueDate', '<=', Timestamp.fromDate(endDate)),\r\n      orderBy('dueDate', 'desc')\r\n    );\r\n    \r\n    const querySnapshot = await getDocs(q);\r\n    const invoices = [];\r\n    \r\n    querySnapshot.forEach((doc) => {\r\n      invoices.push({ id: doc.id, ...doc.data() });\r\n    });\r\n    \r\n    return invoices;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao buscar faturas por período:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// =================== FUNÇÕES AUXILIARES ===================\r\n\r\n/**\r\n * Calcular próxima data de cobrança baseada no ciclo\r\n * @param {Date} startDate - Data de início\r\n * @param {string} billingCycle - Ciclo de cobrança\r\n * @returns {Date} - Próxima data de cobrança\r\n */\r\nconst calculateNextBillingDate = (startDate, billingCycle) => {\r\n  const date = new Date(startDate);\r\n  \r\n  switch (billingCycle) {\r\n    case 'monthly':\r\n      date.setMonth(date.getMonth() + 1);\r\n      break;\r\n    case 'quarterly':\r\n      date.setMonth(date.getMonth() + 3);\r\n      break;\r\n    case 'semiannual':\r\n      date.setMonth(date.getMonth() + 6);\r\n      break;\r\n    case 'annual':\r\n      date.setFullYear(date.getFullYear() + 1);\r\n      break;\r\n    default:\r\n      date.setMonth(date.getMonth() + 1);\r\n  }\r\n  \r\n  return date;\r\n};\r\n\r\n/**\r\n * Gerar faturas para assinaturas do mês\r\n * @param {number} month - Mês (0-11)\r\n * @param {number} year - Ano\r\n */\r\nexport const generateInvoicesForMonth = async (month, year) => {\r\n  try {\r\n    console.log(`🔄 Gerando faturas para ${month + 1}/${year}`);\r\n    \r\n    // Buscar assinaturas ativas\r\n    const subscriptionsQuery = query(\r\n      collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n      where('status', '==', 'active')\r\n    );\r\n    \r\n    const subscriptionsSnapshot = await getDocs(subscriptionsQuery);\r\n    const batch = writeBatch(db);\r\n    let invoicesCreated = 0;\r\n    \r\n    for (const subscriptionDoc of subscriptionsSnapshot.docs) {\r\n      const subscription = { id: subscriptionDoc.id, ...subscriptionDoc.data() };\r\n      \r\n      // Verificar se deve gerar fatura neste mês\r\n      if (shouldGenerateInvoiceForMonth(subscription, month, year)) {\r\n        // Verificar se fatura já existe\r\n        const existingInvoiceQuery = query(\r\n          collection(db, COLLECTIONS.INVOICES),\r\n          where('subscriptionId', '==', subscription.id),\r\n          where('month', '==', month),\r\n          where('year', '==', year)\r\n        );\r\n        \r\n        const existingInvoices = await getDocs(existingInvoiceQuery);\r\n        \r\n        if (existingInvoices.empty) {\r\n          // Criar nova fatura\r\n          const dueDate = new Date(year, month, subscription.billingDay || 5);\r\n          const invoiceRef = doc(collection(db, COLLECTIONS.INVOICES));\r\n          \r\n          batch.set(invoiceRef, {\r\n            clientId: subscription.clientId,\r\n            subscriptionId: subscription.id,\r\n            amount: subscription.amount,\r\n            description: subscription.description,\r\n            dueDate: Timestamp.fromDate(dueDate),\r\n            status: 'pending',\r\n            month,\r\n            year,\r\n            createdAt: Timestamp.now(),\r\n            updatedAt: Timestamp.now()\r\n          });\r\n          \r\n          invoicesCreated++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (invoicesCreated > 0) {\r\n      await batch.commit();\r\n      console.log(`✅ ${invoicesCreated} faturas geradas com sucesso`);\r\n    } else {\r\n      console.log('ℹ️ Nenhuma fatura nova para gerar');\r\n    }\r\n    \r\n    return invoicesCreated;\r\n  } catch (error) {\r\n    console.error('❌ Erro ao gerar faturas:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Verificar se deve gerar fatura para o mês\r\n * @param {Object} subscription - Dados da assinatura\r\n * @param {number} month - Mês (0-11)\r\n * @param {number} year - Ano\r\n * @returns {boolean}\r\n */\r\nconst shouldGenerateInvoiceForMonth = (subscription, month, year) => {\r\n  const startDate = subscription.startDate.toDate();\r\n  const currentDate = new Date(year, month, 1);\r\n  \r\n  // Assinatura deve ter iniciado\r\n  if (startDate > currentDate) {\r\n    return false;\r\n  }\r\n  \r\n  // Verificar ciclo de cobrança\r\n  const startMonth = startDate.getMonth();\r\n  const startYear = startDate.getFullYear();\r\n  \r\n  switch (subscription.billingCycle) {\r\n    case 'monthly':\r\n      return true;\r\n    case 'quarterly':\r\n      return (month - startMonth) % 3 === 0;\r\n    case 'semiannual':\r\n      return (month - startMonth) % 6 === 0;\r\n    case 'annual':\r\n      return month === startMonth;\r\n    default:\r\n      return true;\r\n  }\r\n};\r\n\r\n// =================== DADOS DE EXEMPLO ===================\r\n\r\n/**\r\n * Criar dados de exemplo para teste\r\n */\r\nexport const createSampleData = async () => {\r\n  try {\r\n    console.log('🔄 Criando dados de exemplo...');\r\n    \r\n    // Criar clientes de exemplo\r\n    const clients = [\r\n      {\r\n        name: 'João Silva',\r\n        email: 'joao@email.com',\r\n        phone: '(11) 99999-1111',\r\n        company: 'Silva & Associados',\r\n        address: 'Rua das Flores, 123'\r\n      },\r\n      {\r\n        name: 'Maria Santos',\r\n        email: 'maria@email.com',\r\n        phone: '(11) 99999-2222',\r\n        company: 'Santos Ltda',\r\n        address: 'Av. Principal, 456'\r\n      },\r\n      {\r\n        name: 'Pedro Oliveira',\r\n        email: 'pedro@email.com',\r\n        phone: '(11) 99999-3333',\r\n        company: 'Oliveira Corp',\r\n        address: 'Rua do Comércio, 789'\r\n      }\r\n    ];\r\n    \r\n    const clientIds = [];\r\n    for (const client of clients) {\r\n      const clientId = await createClient(client);\r\n      clientIds.push(clientId);\r\n    }\r\n    \r\n    // Criar assinaturas de exemplo\r\n    const subscriptions = [\r\n      {\r\n        clientId: clientIds[0],\r\n        service: 'Website Básico',\r\n        description: 'Manutenção mensal do website',\r\n        amount: 300,\r\n        billingCycle: 'monthly',\r\n        startDate: new Date('2024-01-01'),\r\n        status: 'active',\r\n        billingDay: 5\r\n      },\r\n      {\r\n        clientId: clientIds[1],\r\n        service: 'SEO Premium',\r\n        description: 'Otimização SEO completa',\r\n        amount: 800,\r\n        billingCycle: 'monthly',\r\n        startDate: new Date('2024-02-01'),\r\n        status: 'active',\r\n        billingDay: 10\r\n      },\r\n      {\r\n        clientId: clientIds[2],\r\n        service: 'Consultoria Anual',\r\n        description: 'Consultoria estratégica anual',\r\n        amount: 5000,\r\n        billingCycle: 'annual',\r\n        startDate: new Date('2024-01-15'),\r\n        status: 'active',\r\n        billingDay: 15\r\n      }\r\n    ];\r\n    \r\n    const subscriptionIds = [];\r\n    for (const subscription of subscriptions) {\r\n      const subscriptionId = await createSubscription(subscription);\r\n      subscriptionIds.push(subscriptionId);\r\n    }\r\n    \r\n    // Criar algumas faturas de exemplo\r\n    const invoices = [\r\n      {\r\n        clientId: clientIds[0],\r\n        subscriptionId: subscriptionIds[0],\r\n        amount: 300,\r\n        description: 'Website Básico - Janeiro 2024',\r\n        dueDate: new Date('2024-01-05'),\r\n        status: 'paid',\r\n        month: 0,\r\n        year: 2024,\r\n        paidAt: new Date('2024-01-03')\r\n      },\r\n      {\r\n        clientId: clientIds[1],\r\n        subscriptionId: subscriptionIds[1],\r\n        amount: 800,\r\n        description: 'SEO Premium - Fevereiro 2024',\r\n        dueDate: new Date('2024-02-10'),\r\n        status: 'pending',\r\n        month: 1,\r\n        year: 2024\r\n      }\r\n    ];\r\n    \r\n    for (const invoice of invoices) {\r\n      await createInvoice(invoice);\r\n    }\r\n    \r\n    console.log('✅ Dados de exemplo criados com sucesso!');\r\n    return {\r\n      clients: clientIds.length,\r\n      subscriptions: subscriptionIds.length,\r\n      invoices: invoices.length\r\n    };\r\n    \r\n  } catch (error) {\r\n    console.error('❌ Erro ao criar dados de exemplo:', error);\r\n    throw error;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}