// src/hooks/useAutomation.js - VERSÃƒO CORRIGIDA
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:3001/api';

export const useAutomation = () => {
  const [isRunning, setIsRunning] = useState(null); // null = nÃ£o carregado ainda
  const [config, setConfig] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [stats, setStats] = useState({});
  const [logs, setLogs] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState(null);

  // âœ… FunÃ§Ã£o para buscar status com retry e melhor error handling
  const fetchStatus = useCallback(async (retries = 3, showLoading = true) => {
    if (showLoading) setLoading(true);
    
    for (let i = 0; i < retries; i++) {
      try {
        console.log(`ðŸ“¡ [useAutomation] Buscando status (tentativa ${i + 1})...`);
        
        const response = await axios.get(`${API_BASE_URL}/automation/status`, {
          timeout: 10000,
          headers: {
            'Content-Type': 'application/json'
          }
        });

        console.log('âœ… [useAutomation] Status recebido:', response.data);
        
        // âœ… Atualizar estados baseado na resposta
        setIsRunning(response.data.isRunning);
        setConfig(response.data.config || {});
        setStats(response.data.stats || {});
        setError(null);
        
        if (showLoading) setLoading(false);
        return response.data;
        
      } catch (err) {
        console.error(`âŒ [useAutomation] Erro na tentativa ${i + 1}:`, err.message);
        
        if (i === retries - 1) {
          // Ãšltima tentativa falhou
          setError(`Falha ao conectar: ${err.message}`);
          setIsRunning(false); // Assumir parado se nÃ£o conseguir conectar
          if (showLoading) setLoading(false);
          return { isRunning: false, error: err.message };
        } else {
          // Tentar novamente apÃ³s delay
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }
  }, []);

  // âœ… Iniciar automaÃ§Ã£o com feedback imediato
  const startAutomation = useCallback(async () => {
    console.log('ðŸš€ [useAutomation] Iniciando automaÃ§Ã£o...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/start`, {}, {
        timeout: 30000, // 30 segundos para dar tempo
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('âœ… [useAutomation] Resposta do start:', response.data);
      
      if (response.data.success) {
        // âœ… Atualizar estado imediatamente
        setIsRunning(true);
        
        // âœ… Verificar status apÃ³s 2 segundos para confirmar
        setTimeout(() => {
          fetchStatus(1, false); // 1 tentativa, sem loading
        }, 2000);
        
        return { success: true, message: 'AutomaÃ§Ã£o iniciada!' };
      } else {
        throw new Error(response.data.error || 'Falha ao iniciar');
      }
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro ao iniciar:', err.message);
      setError(`Erro ao iniciar: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // âœ… Parar automaÃ§Ã£o com feedback imediato
  const stopAutomation = useCallback(async () => {
    console.log('ðŸ›‘ [useAutomation] Parando automaÃ§Ã£o...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/stop`, {}, {
        timeout: 15000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('âœ… [useAutomation] Resposta do stop:', response.data);
      
      if (response.data.success) {
        // âœ… Atualizar estado imediatamente
        setIsRunning(false);
        
        // âœ… Verificar status apÃ³s 1 segundo para confirmar
        setTimeout(() => {
          fetchStatus(1, false);
        }, 1000);
        
        return { success: true, message: 'AutomaÃ§Ã£o parada!' };
      } else {
        throw new Error(response.data.error || 'Falha ao parar');
      }
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro ao parar:', err.message);
      setError(`Erro ao parar: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // âœ… Executar ciclo manual
  const runManualCycle = useCallback(async () => {
    console.log('ðŸ”„ [useAutomation] Executando ciclo manual...');
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/manual-cycle`, {}, {
        timeout: 30000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('âœ… [useAutomation] Resultado do ciclo manual:', response.data);
      
      // âœ… Atualizar stats apÃ³s ciclo manual
      setTimeout(() => {
        fetchStatus(1, false);
      }, 1000);
      
      return response.data;
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro no ciclo manual:', err.message);
      setError(`Erro no ciclo manual: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // âœ… Atualizar configuraÃ§Ã£o
  const updateConfig = useCallback(async (newConfig) => {
    console.log('âš™ï¸ [useAutomation] Atualizando configuraÃ§Ã£o:', newConfig);
    setLoading(true);
    
    try {
      const response = await axios.put(`${API_BASE_URL}/automation/config`, {
        config: newConfig
      }, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('âœ… [useAutomation] ConfiguraÃ§Ã£o atualizada:', response.data);
      
      if (response.data.success) {
        setConfig(response.data.config || newConfig);
        return { success: true, config: response.data.config };
      }
      
      return response.data;
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro ao atualizar config:', err.message);
      setError(`Erro na configuraÃ§Ã£o: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, []);

  // âœ… Testar conexÃµes
  const testConnections = useCallback(async () => {
    console.log('ðŸ” [useAutomation] Testando conexÃµes...');
    setLoading(true);
    
    try {
      const response = await axios.get(`${API_BASE_URL}/health`, {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      console.log('âœ… [useAutomation] Health check:', response.data);
      setConnectionStatus(response.data.health);
      return response.data;
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro no teste:', err.message);
      setError(`Erro no teste: ${err.message}`);
      setConnectionStatus({ database: false, whatsapp: { connected: false }, error: err.message });
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, []);

  // âœ… Buscar estatÃ­sticas
  const getAutomationStats = useCallback(async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/automation/performance?days=7`, {
        timeout: 10000
      });
      
      console.log('ðŸ“Š [useAutomation] Stats recebidas:', response.data);
      setStats(response.data.report || {});
      return response.data;
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro nas stats:', err.message);
      return { error: err.message };
    }
  }, []);

  // âœ… Buscar logs
  const getLogs = useCallback(async (limit = 50) => {
    try {
      const response = await axios.get(`${API_BASE_URL}/automation/logs?limit=${limit}`, {
        timeout: 10000
      });
      
      console.log('ðŸ“œ [useAutomation] Logs recebidos:', response.data);
      setLogs(response.data.logs || []);
      return response.data.logs || [];
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro nos logs:', err.message);
      return [];
    }
  }, []);

  // âœ… Reset completo
  const resetAutomation = useCallback(async () => {
    console.log('ðŸ”„ [useAutomation] Fazendo reset...');
    setLoading(true);
    
    try {
      const response = await axios.post(`${API_BASE_URL}/automation/reset`, {}, {
        timeout: 15000
      });
      
      console.log('âœ… [useAutomation] Reset concluÃ­do:', response.data);
      
      // âœ… Limpar estados locais
      setIsRunning(false);
      setStats({});
      setLogs([]);
      setError(null);
      
      // âœ… Recarregar status
      setTimeout(() => {
        fetchStatus();
      }, 1000);
      
      return response.data;
      
    } catch (err) {
      console.error('âŒ [useAutomation] Erro no reset:', err.message);
      setError(`Erro no reset: ${err.message}`);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, [fetchStatus]);

  // âœ… Carregar status inicial
  useEffect(() => {
    console.log('ðŸ› ï¸ [useAutomation] Hook inicializado, carregando status...');
    fetchStatus();
  }, [fetchStatus]);

  // âœ… Polling periÃ³dico para manter sincronizado (a cada 30 segundos)
  useEffect(() => {
    const interval = setInterval(() => {
      if (!loading) {
        console.log('ðŸ”„ [useAutomation] Polling status...');
        fetchStatus(1, false); // 1 tentativa, sem loading
      }
    }, 30000); // 30 segundos

    return () => clearInterval(interval);
  }, [fetchStatus, loading]);

  // âœ… SSE para updates em tempo real (se disponÃ­vel)
  useEffect(() => {
    console.log('ðŸ“¡ [useAutomation] Tentando conectar SSE...');
    
    let eventSource;
    let reconnectTimeout;
    
    const connectSSE = () => {
      try {
        eventSource = new EventSource(`${API_BASE_URL}/automation/events`);
        
        eventSource.onopen = () => {
          console.log('âœ… [useAutomation] SSE conectado');
          setError(null);
        };
        
        eventSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log('ðŸ“¨ [useAutomation] SSE update:', data);
            
            // âœ… Atualizar estados com dados do SSE
            if (data.isRunning !== undefined) {
              setIsRunning(data.isRunning);
            }
            if (data.config) {
              setConfig(data.config);
            }
            if (data.stats) {
              setStats(data.stats);
            }
            
            setLoading(false);
            setError(null);
            
          } catch (parseError) {
            console.error('âŒ [useAutomation] Erro ao processar SSE:', parseError);
          }
        };
        
        eventSource.onerror = (error) => {
          console.error('âŒ [useAutomation] Erro SSE:', error);
          eventSource.close();
          
          // âœ… Reconectar apÃ³s 5 segundos
          reconnectTimeout = setTimeout(() => {
            console.log('ðŸ”„ [useAutomation] Tentando reconectar SSE...');
            connectSSE();
          }, 5000);
        };
        
      } catch (error) {
        console.error('âŒ [useAutomation] Erro ao conectar SSE:', error);
      }
    };
    
    // Conectar SSE
    connectSSE();
    
    // âœ… Cleanup
    return () => {
      if (eventSource) {
        console.log('ðŸ›‘ [useAutomation] Fechando SSE');
        eventSource.close();
      }
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
    };
  }, []);

  return {
    // âœ… Estados
    isRunning,
    config,
    loading,
    error,
    stats,
    logs,
    connectionStatus,

    // âœ… AÃ§Ãµes principais
    startAutomation,
    stopAutomation,
    runManualCycle,
    updateConfig,
    resetAutomation,

    // âœ… InformaÃ§Ãµes
    getAutomationStats,
    getLogs,
    testConnections,
    getStatus: fetchStatus,

    // âœ… UtilitÃ¡rios
    isConnected: connectionStatus?.database && connectionStatus?.whatsapp?.connected,
    hasError: !!error,
    isLoading: loading,
    canStart: !loading && !isRunning,
    canStop: !loading && isRunning
  };
};
