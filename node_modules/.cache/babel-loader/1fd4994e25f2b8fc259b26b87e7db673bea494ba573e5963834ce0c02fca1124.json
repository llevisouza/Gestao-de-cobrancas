{"ast":null,"code":"// src/services/firestore.js\nimport { collection, doc, addDoc, updateDoc, deleteDoc, getDocs, onSnapshot, query, orderBy, where, Timestamp, writeBatch } from 'firebase/firestore';\nimport { db } from './firebase';\n\n// Constantes das coleções\nexport const COLLECTIONS = {\n  CLIENTS: 'clients',\n  SUBSCRIPTIONS: 'subscriptions',\n  INVOICES: 'invoices'\n};\n\n// =================== CLIENT SERVICE ===================\nexport const clientService = {\n  // Criar cliente\n  create: async clientData => {\n    try {\n      const docRef = await addDoc(collection(db, COLLECTIONS.CLIENTS), {\n        ...clientData,\n        createdAt: Timestamp.now(),\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Cliente criado:', docRef.id);\n      return docRef.id;\n    } catch (error) {\n      console.error('❌ Erro ao criar cliente:', error);\n      throw error;\n    }\n  },\n  // Atualizar cliente\n  update: async (clientId, clientData) => {\n    try {\n      const clientRef = doc(db, COLLECTIONS.CLIENTS, clientId);\n      await updateDoc(clientRef, {\n        ...clientData,\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Cliente atualizado:', clientId);\n    } catch (error) {\n      console.error('❌ Erro ao atualizar cliente:', error);\n      throw error;\n    }\n  },\n  // Deletar cliente\n  delete: async clientId => {\n    try {\n      // Verificar se há assinaturas ativas\n      const subscriptionsQuery = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('clientId', '==', clientId), where('status', '==', 'active'));\n      const activeSubscriptions = await getDocs(subscriptionsQuery);\n      if (!activeSubscriptions.empty) {\n        throw new Error('Não é possível deletar cliente com assinaturas ativas');\n      }\n      await deleteDoc(doc(db, COLLECTIONS.CLIENTS, clientId));\n      console.log('✅ Cliente deletado:', clientId);\n    } catch (error) {\n      console.error('❌ Erro ao deletar cliente:', error);\n      throw error;\n    }\n  },\n  // Buscar todos os clientes\n  getAll: async () => {\n    try {\n      const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\n      const querySnapshot = await getDocs(q);\n      const clients = [];\n      querySnapshot.forEach(doc => {\n        clients.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      return clients;\n    } catch (error) {\n      console.error('❌ Erro ao buscar clientes:', error);\n      throw error;\n    }\n  },\n  // Subscrever para mudanças\n  subscribe: callback => {\n    const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\n    return onSnapshot(q, querySnapshot => {\n      const clients = [];\n      querySnapshot.forEach(doc => {\n        clients.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      callback(clients);\n    }, error => {\n      console.error('❌ Erro na subscrição de clientes:', error);\n    });\n  }\n};\n\n// =================== SUBSCRIPTION SERVICE ===================\nexport const subscriptionService = {\n  // Criar assinatura\n  create: async subscriptionData => {\n    try {\n      // Calcular próxima data de cobrança\n      const nextBillingDate = calculateNextBillingDate(subscriptionData.startDate, subscriptionData.billingCycle);\n      const docRef = await addDoc(collection(db, COLLECTIONS.SUBSCRIPTIONS), {\n        ...subscriptionData,\n        nextBillingDate: Timestamp.fromDate(nextBillingDate),\n        createdAt: Timestamp.now(),\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Assinatura criada:', docRef.id);\n      return docRef.id;\n    } catch (error) {\n      console.error('❌ Erro ao criar assinatura:', error);\n      throw error;\n    }\n  },\n  // Atualizar assinatura\n  update: async (subscriptionId, subscriptionData) => {\n    try {\n      const subscriptionRef = doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId);\n      await updateDoc(subscriptionRef, {\n        ...subscriptionData,\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Assinatura atualizada:', subscriptionId);\n    } catch (error) {\n      console.error('❌ Erro ao atualizar assinatura:', error);\n      throw error;\n    }\n  },\n  // Deletar assinatura\n  delete: async subscriptionId => {\n    try {\n      await deleteDoc(doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId));\n      console.log('✅ Assinatura deletada:', subscriptionId);\n    } catch (error) {\n      console.error('❌ Erro ao deletar assinatura:', error);\n      throw error;\n    }\n  },\n  // Buscar assinaturas por cliente\n  getByClient: async clientId => {\n    try {\n      const q = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('clientId', '==', clientId), orderBy('createdAt', 'desc'));\n      const querySnapshot = await getDocs(q);\n      const subscriptions = [];\n      querySnapshot.forEach(doc => {\n        subscriptions.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      return subscriptions;\n    } catch (error) {\n      console.error('❌ Erro ao buscar assinaturas:', error);\n      throw error;\n    }\n  },\n  // Subscrever para mudanças\n  subscribe: callback => {\n    const q = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), orderBy('createdAt', 'desc'));\n    return onSnapshot(q, querySnapshot => {\n      const subscriptions = [];\n      querySnapshot.forEach(doc => {\n        subscriptions.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      callback(subscriptions);\n    });\n  }\n};\n\n// =================== INVOICE SERVICE ===================\nexport const invoiceService = {\n  // Criar fatura\n  create: async invoiceData => {\n    try {\n      const docRef = await addDoc(collection(db, COLLECTIONS.INVOICES), {\n        ...invoiceData,\n        createdAt: Timestamp.now(),\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Fatura criada:', docRef.id);\n      return docRef.id;\n    } catch (error) {\n      console.error('❌ Erro ao criar fatura:', error);\n      throw error;\n    }\n  },\n  // Atualizar fatura\n  update: async (invoiceId, invoiceData) => {\n    try {\n      const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\n      await updateDoc(invoiceRef, {\n        ...invoiceData,\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Fatura atualizada:', invoiceId);\n    } catch (error) {\n      console.error('❌ Erro ao atualizar fatura:', error);\n      throw error;\n    }\n  },\n  // Deletar fatura\n  delete: async invoiceId => {\n    try {\n      await deleteDoc(doc(db, COLLECTIONS.INVOICES, invoiceId));\n      console.log('✅ Fatura deletada:', invoiceId);\n    } catch (error) {\n      console.error('❌ Erro ao deletar fatura:', error);\n      throw error;\n    }\n  },\n  // Marcar fatura como paga\n  markAsPaid: async invoiceId => {\n    try {\n      const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\n      await updateDoc(invoiceRef, {\n        status: 'paid',\n        paidAt: Timestamp.now(),\n        updatedAt: Timestamp.now()\n      });\n      console.log('✅ Fatura marcada como paga:', invoiceId);\n    } catch (error) {\n      console.error('❌ Erro ao marcar fatura como paga:', error);\n      throw error;\n    }\n  },\n  // Buscar faturas por período\n  getByPeriod: async (startDate, endDate) => {\n    try {\n      const q = query(collection(db, COLLECTIONS.INVOICES), where('dueDate', '>=', Timestamp.fromDate(startDate)), where('dueDate', '<=', Timestamp.fromDate(endDate)), orderBy('dueDate', 'desc'));\n      const querySnapshot = await getDocs(q);\n      const invoices = [];\n      querySnapshot.forEach(doc => {\n        invoices.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      return invoices;\n    } catch (error) {\n      console.error('❌ Erro ao buscar faturas por período:', error);\n      throw error;\n    }\n  },\n  // Gerar faturas para o mês\n  generateForMonth: async (month, year) => {\n    try {\n      console.log(`🔄 Gerando faturas para ${month + 1}/${year}`);\n\n      // Buscar assinaturas ativas\n      const subscriptionsQuery = query(collection(db, COLLECTIONS.SUBSCRIPTIONS), where('status', '==', 'active'));\n      const subscriptionsSnapshot = await getDocs(subscriptionsQuery);\n      const batch = writeBatch(db);\n      let invoicesCreated = 0;\n      for (const subscriptionDoc of subscriptionsSnapshot.docs) {\n        const subscription = {\n          id: subscriptionDoc.id,\n          ...subscriptionDoc.data()\n        };\n\n        // Verificar se deve gerar fatura neste mês\n        if (shouldGenerateInvoiceForMonth(subscription, month, year)) {\n          // Verificar se fatura já existe\n          const existingInvoiceQuery = query(collection(db, COLLECTIONS.INVOICES), where('subscriptionId', '==', subscription.id), where('month', '==', month), where('year', '==', year));\n          const existingInvoices = await getDocs(existingInvoiceQuery);\n          if (existingInvoices.empty) {\n            // Criar nova fatura\n            const dueDate = new Date(year, month, subscription.billingDay || 5);\n            const invoiceRef = doc(collection(db, COLLECTIONS.INVOICES));\n            batch.set(invoiceRef, {\n              clientId: subscription.clientId,\n              subscriptionId: subscription.id,\n              amount: subscription.amount,\n              description: subscription.description,\n              dueDate: Timestamp.fromDate(dueDate),\n              status: 'pending',\n              month,\n              year,\n              createdAt: Timestamp.now(),\n              updatedAt: Timestamp.now()\n            });\n            invoicesCreated++;\n          }\n        }\n      }\n      if (invoicesCreated > 0) {\n        await batch.commit();\n        console.log(`✅ ${invoicesCreated} faturas geradas com sucesso`);\n      } else {\n        console.log('ℹ️ Nenhuma fatura nova para gerar');\n      }\n      return invoicesCreated;\n    } catch (error) {\n      console.error('❌ Erro ao gerar faturas:', error);\n      throw error;\n    }\n  },\n  // Subscrever para mudanças\n  subscribe: callback => {\n    const q = query(collection(db, COLLECTIONS.INVOICES), orderBy('dueDate', 'desc'));\n    return onSnapshot(q, querySnapshot => {\n      const invoices = [];\n      querySnapshot.forEach(doc => {\n        invoices.push({\n          id: doc.id,\n          ...doc.data()\n        });\n      });\n      callback(invoices);\n    });\n  }\n};\n\n// =================== SEED SERVICE ===================\nexport const seedService = {\n  createSampleData: async () => {\n    try {\n      console.log('🔄 Criando dados de exemplo...');\n\n      // Criar clientes de exemplo\n      const clients = [{\n        name: 'João Silva',\n        email: 'joao@email.com',\n        phone: '(11) 99999-1111',\n        company: 'Silva & Associados',\n        address: 'Rua das Flores, 123'\n      }, {\n        name: 'Maria Santos',\n        email: 'maria@email.com',\n        phone: '(11) 99999-2222',\n        company: 'Santos Ltda',\n        address: 'Av. Principal, 456'\n      }, {\n        name: 'Pedro Oliveira',\n        email: 'pedro@email.com',\n        phone: '(11) 99999-3333',\n        company: 'Oliveira Corp',\n        address: 'Rua do Comércio, 789'\n      }];\n      const clientIds = [];\n      for (const client of clients) {\n        const clientId = await clientService.create(client);\n        clientIds.push(clientId);\n      }\n\n      // Criar assinaturas de exemplo\n      const subscriptions = [{\n        clientId: clientIds[0],\n        service: 'Website Básico',\n        description: 'Manutenção mensal do website',\n        amount: 300,\n        billingCycle: 'monthly',\n        startDate: new Date('2024-01-01'),\n        status: 'active',\n        billingDay: 5\n      }, {\n        clientId: clientIds[1],\n        service: 'SEO Premium',\n        description: 'Otimização SEO completa',\n        amount: 800,\n        billingCycle: 'monthly',\n        startDate: new Date('2024-02-01'),\n        status: 'active',\n        billingDay: 10\n      }, {\n        clientId: clientIds[2],\n        service: 'Consultoria Anual',\n        description: 'Consultoria estratégica anual',\n        amount: 5000,\n        billingCycle: 'annual',\n        startDate: new Date('2024-01-15'),\n        status: 'active',\n        billingDay: 15\n      }];\n      const subscriptionIds = [];\n      for (const subscription of subscriptions) {\n        const subscriptionId = await subscriptionService.create(subscription);\n        subscriptionIds.push(subscriptionId);\n      }\n\n      // Criar algumas faturas de exemplo\n      const invoices = [{\n        clientId: clientIds[0],\n        subscriptionId: subscriptionIds[0],\n        amount: 300,\n        description: 'Website Básico - Janeiro 2025',\n        dueDate: new Date('2025-01-05'),\n        status: 'paid',\n        month: 0,\n        year: 2025,\n        paidAt: Timestamp.now()\n      }, {\n        clientId: clientIds[1],\n        subscriptionId: subscriptionIds[1],\n        amount: 800,\n        description: 'SEO Premium - Janeiro 2025',\n        dueDate: new Date('2025-01-10'),\n        status: 'pending',\n        month: 0,\n        year: 2025\n      }];\n      for (const invoice of invoices) {\n        await invoiceService.create(invoice);\n      }\n      console.log('✅ Dados de exemplo criados com sucesso!');\n      return {\n        clients: clientIds.length,\n        subscriptions: subscriptionIds.length,\n        invoices: invoices.length\n      };\n    } catch (error) {\n      console.error('❌ Erro ao criar dados de exemplo:', error);\n      throw error;\n    }\n  }\n};\n\n// =================== FUNÇÕES AUXILIARES ===================\n\n/**\r\n * Calcular próxima data de cobrança baseada no ciclo\r\n */\nconst calculateNextBillingDate = (startDate, billingCycle) => {\n  const date = new Date(startDate);\n  switch (billingCycle) {\n    case 'monthly':\n      date.setMonth(date.getMonth() + 1);\n      break;\n    case 'quarterly':\n      date.setMonth(date.getMonth() + 3);\n      break;\n    case 'semiannual':\n      date.setMonth(date.getMonth() + 6);\n      break;\n    case 'annual':\n      date.setFullYear(date.getFullYear() + 1);\n      break;\n    default:\n      date.setMonth(date.getMonth() + 1);\n  }\n  return date;\n};\n\n/**\r\n * Verificar se deve gerar fatura para o mês\r\n */\nconst shouldGenerateInvoiceForMonth = (subscription, month, year) => {\n  const startDate = subscription.startDate.toDate();\n  const currentDate = new Date(year, month, 1);\n\n  // Assinatura deve ter iniciado\n  if (startDate > currentDate) {\n    return false;\n  }\n\n  // Verificar ciclo de cobrança\n  const startMonth = startDate.getMonth();\n  switch (subscription.billingCycle) {\n    case 'monthly':\n      return true;\n    case 'quarterly':\n      return (month - startMonth) % 3 === 0;\n    case 'semiannual':\n      return (month - startMonth) % 6 === 0;\n    case 'annual':\n      return month === startMonth;\n    default:\n      return true;\n  }\n};","map":{"version":3,"names":["collection","doc","addDoc","updateDoc","deleteDoc","getDocs","onSnapshot","query","orderBy","where","Timestamp","writeBatch","db","COLLECTIONS","CLIENTS","SUBSCRIPTIONS","INVOICES","clientService","create","clientData","docRef","createdAt","now","updatedAt","console","log","id","error","update","clientId","clientRef","delete","subscriptionsQuery","activeSubscriptions","empty","Error","getAll","q","querySnapshot","clients","forEach","push","data","subscribe","callback","subscriptionService","subscriptionData","nextBillingDate","calculateNextBillingDate","startDate","billingCycle","fromDate","subscriptionId","subscriptionRef","getByClient","subscriptions","invoiceService","invoiceData","invoiceId","invoiceRef","markAsPaid","status","paidAt","getByPeriod","endDate","invoices","generateForMonth","month","year","subscriptionsSnapshot","batch","invoicesCreated","subscriptionDoc","docs","subscription","shouldGenerateInvoiceForMonth","existingInvoiceQuery","existingInvoices","dueDate","Date","billingDay","set","amount","description","commit","seedService","createSampleData","name","email","phone","company","address","clientIds","client","service","subscriptionIds","invoice","length","date","setMonth","getMonth","setFullYear","getFullYear","toDate","currentDate","startMonth"],"sources":["C:/Users/LEVI/Desktop/Gestao-de-cobrancas/src/hooks/useFirestore.js"],"sourcesContent":["// src/services/firestore.js\r\nimport { \r\n  collection, \r\n  doc, \r\n  addDoc, \r\n  updateDoc, \r\n  deleteDoc, \r\n  getDocs, \r\n  onSnapshot,\r\n  query,\r\n  orderBy,\r\n  where,\r\n  Timestamp,\r\n  writeBatch\r\n} from 'firebase/firestore';\r\nimport { db } from './firebase';\r\n\r\n// Constantes das coleções\r\nexport const COLLECTIONS = {\r\n  CLIENTS: 'clients',\r\n  SUBSCRIPTIONS: 'subscriptions',\r\n  INVOICES: 'invoices'\r\n};\r\n\r\n// =================== CLIENT SERVICE ===================\r\nexport const clientService = {\r\n  // Criar cliente\r\n  create: async (clientData) => {\r\n    try {\r\n      const docRef = await addDoc(collection(db, COLLECTIONS.CLIENTS), {\r\n        ...clientData,\r\n        createdAt: Timestamp.now(),\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      console.log('✅ Cliente criado:', docRef.id);\r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao criar cliente:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Atualizar cliente\r\n  update: async (clientId, clientData) => {\r\n    try {\r\n      const clientRef = doc(db, COLLECTIONS.CLIENTS, clientId);\r\n      await updateDoc(clientRef, {\r\n        ...clientData,\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      console.log('✅ Cliente atualizado:', clientId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao atualizar cliente:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Deletar cliente\r\n  delete: async (clientId) => {\r\n    try {\r\n      // Verificar se há assinaturas ativas\r\n      const subscriptionsQuery = query(\r\n        collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n        where('clientId', '==', clientId),\r\n        where('status', '==', 'active')\r\n      );\r\n      const activeSubscriptions = await getDocs(subscriptionsQuery);\r\n      \r\n      if (!activeSubscriptions.empty) {\r\n        throw new Error('Não é possível deletar cliente com assinaturas ativas');\r\n      }\r\n\r\n      await deleteDoc(doc(db, COLLECTIONS.CLIENTS, clientId));\r\n      console.log('✅ Cliente deletado:', clientId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao deletar cliente:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Buscar todos os clientes\r\n  getAll: async () => {\r\n    try {\r\n      const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\r\n      const querySnapshot = await getDocs(q);\r\n      const clients = [];\r\n      \r\n      querySnapshot.forEach((doc) => {\r\n        clients.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      \r\n      return clients;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao buscar clientes:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Subscrever para mudanças\r\n  subscribe: (callback) => {\r\n    const q = query(collection(db, COLLECTIONS.CLIENTS), orderBy('name'));\r\n    \r\n    return onSnapshot(q, (querySnapshot) => {\r\n      const clients = [];\r\n      querySnapshot.forEach((doc) => {\r\n        clients.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      callback(clients);\r\n    }, (error) => {\r\n      console.error('❌ Erro na subscrição de clientes:', error);\r\n    });\r\n  }\r\n};\r\n\r\n// =================== SUBSCRIPTION SERVICE ===================\r\nexport const subscriptionService = {\r\n  // Criar assinatura\r\n  create: async (subscriptionData) => {\r\n    try {\r\n      // Calcular próxima data de cobrança\r\n      const nextBillingDate = calculateNextBillingDate(\r\n        subscriptionData.startDate,\r\n        subscriptionData.billingCycle\r\n      );\r\n\r\n      const docRef = await addDoc(collection(db, COLLECTIONS.SUBSCRIPTIONS), {\r\n        ...subscriptionData,\r\n        nextBillingDate: Timestamp.fromDate(nextBillingDate),\r\n        createdAt: Timestamp.now(),\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      \r\n      console.log('✅ Assinatura criada:', docRef.id);\r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao criar assinatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Atualizar assinatura\r\n  update: async (subscriptionId, subscriptionData) => {\r\n    try {\r\n      const subscriptionRef = doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId);\r\n      await updateDoc(subscriptionRef, {\r\n        ...subscriptionData,\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      console.log('✅ Assinatura atualizada:', subscriptionId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao atualizar assinatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Deletar assinatura\r\n  delete: async (subscriptionId) => {\r\n    try {\r\n      await deleteDoc(doc(db, COLLECTIONS.SUBSCRIPTIONS, subscriptionId));\r\n      console.log('✅ Assinatura deletada:', subscriptionId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao deletar assinatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Buscar assinaturas por cliente\r\n  getByClient: async (clientId) => {\r\n    try {\r\n      const q = query(\r\n        collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n        where('clientId', '==', clientId),\r\n        orderBy('createdAt', 'desc')\r\n      );\r\n      const querySnapshot = await getDocs(q);\r\n      const subscriptions = [];\r\n      \r\n      querySnapshot.forEach((doc) => {\r\n        subscriptions.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      \r\n      return subscriptions;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao buscar assinaturas:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Subscrever para mudanças\r\n  subscribe: (callback) => {\r\n    const q = query(\r\n      collection(db, COLLECTIONS.SUBSCRIPTIONS), \r\n      orderBy('createdAt', 'desc')\r\n    );\r\n    \r\n    return onSnapshot(q, (querySnapshot) => {\r\n      const subscriptions = [];\r\n      querySnapshot.forEach((doc) => {\r\n        subscriptions.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      callback(subscriptions);\r\n    });\r\n  }\r\n};\r\n\r\n// =================== INVOICE SERVICE ===================\r\nexport const invoiceService = {\r\n  // Criar fatura\r\n  create: async (invoiceData) => {\r\n    try {\r\n      const docRef = await addDoc(collection(db, COLLECTIONS.INVOICES), {\r\n        ...invoiceData,\r\n        createdAt: Timestamp.now(),\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      \r\n      console.log('✅ Fatura criada:', docRef.id);\r\n      return docRef.id;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao criar fatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Atualizar fatura\r\n  update: async (invoiceId, invoiceData) => {\r\n    try {\r\n      const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\r\n      await updateDoc(invoiceRef, {\r\n        ...invoiceData,\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      console.log('✅ Fatura atualizada:', invoiceId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao atualizar fatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Deletar fatura\r\n  delete: async (invoiceId) => {\r\n    try {\r\n      await deleteDoc(doc(db, COLLECTIONS.INVOICES, invoiceId));\r\n      console.log('✅ Fatura deletada:', invoiceId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao deletar fatura:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Marcar fatura como paga\r\n  markAsPaid: async (invoiceId) => {\r\n    try {\r\n      const invoiceRef = doc(db, COLLECTIONS.INVOICES, invoiceId);\r\n      await updateDoc(invoiceRef, {\r\n        status: 'paid',\r\n        paidAt: Timestamp.now(),\r\n        updatedAt: Timestamp.now()\r\n      });\r\n      console.log('✅ Fatura marcada como paga:', invoiceId);\r\n    } catch (error) {\r\n      console.error('❌ Erro ao marcar fatura como paga:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Buscar faturas por período\r\n  getByPeriod: async (startDate, endDate) => {\r\n    try {\r\n      const q = query(\r\n        collection(db, COLLECTIONS.INVOICES),\r\n        where('dueDate', '>=', Timestamp.fromDate(startDate)),\r\n        where('dueDate', '<=', Timestamp.fromDate(endDate)),\r\n        orderBy('dueDate', 'desc')\r\n      );\r\n      \r\n      const querySnapshot = await getDocs(q);\r\n      const invoices = [];\r\n      \r\n      querySnapshot.forEach((doc) => {\r\n        invoices.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      \r\n      return invoices;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao buscar faturas por período:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Gerar faturas para o mês\r\n  generateForMonth: async (month, year) => {\r\n    try {\r\n      console.log(`🔄 Gerando faturas para ${month + 1}/${year}`);\r\n      \r\n      // Buscar assinaturas ativas\r\n      const subscriptionsQuery = query(\r\n        collection(db, COLLECTIONS.SUBSCRIPTIONS),\r\n        where('status', '==', 'active')\r\n      );\r\n      \r\n      const subscriptionsSnapshot = await getDocs(subscriptionsQuery);\r\n      const batch = writeBatch(db);\r\n      let invoicesCreated = 0;\r\n      \r\n      for (const subscriptionDoc of subscriptionsSnapshot.docs) {\r\n        const subscription = { id: subscriptionDoc.id, ...subscriptionDoc.data() };\r\n        \r\n        // Verificar se deve gerar fatura neste mês\r\n        if (shouldGenerateInvoiceForMonth(subscription, month, year)) {\r\n          // Verificar se fatura já existe\r\n          const existingInvoiceQuery = query(\r\n            collection(db, COLLECTIONS.INVOICES),\r\n            where('subscriptionId', '==', subscription.id),\r\n            where('month', '==', month),\r\n            where('year', '==', year)\r\n          );\r\n          \r\n          const existingInvoices = await getDocs(existingInvoiceQuery);\r\n          \r\n          if (existingInvoices.empty) {\r\n            // Criar nova fatura\r\n            const dueDate = new Date(year, month, subscription.billingDay || 5);\r\n            const invoiceRef = doc(collection(db, COLLECTIONS.INVOICES));\r\n            \r\n            batch.set(invoiceRef, {\r\n              clientId: subscription.clientId,\r\n              subscriptionId: subscription.id,\r\n              amount: subscription.amount,\r\n              description: subscription.description,\r\n              dueDate: Timestamp.fromDate(dueDate),\r\n              status: 'pending',\r\n              month,\r\n              year,\r\n              createdAt: Timestamp.now(),\r\n              updatedAt: Timestamp.now()\r\n            });\r\n            \r\n            invoicesCreated++;\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (invoicesCreated > 0) {\r\n        await batch.commit();\r\n        console.log(`✅ ${invoicesCreated} faturas geradas com sucesso`);\r\n      } else {\r\n        console.log('ℹ️ Nenhuma fatura nova para gerar');\r\n      }\r\n      \r\n      return invoicesCreated;\r\n    } catch (error) {\r\n      console.error('❌ Erro ao gerar faturas:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Subscrever para mudanças\r\n  subscribe: (callback) => {\r\n    const q = query(\r\n      collection(db, COLLECTIONS.INVOICES), \r\n      orderBy('dueDate', 'desc')\r\n    );\r\n    \r\n    return onSnapshot(q, (querySnapshot) => {\r\n      const invoices = [];\r\n      querySnapshot.forEach((doc) => {\r\n        invoices.push({ id: doc.id, ...doc.data() });\r\n      });\r\n      callback(invoices);\r\n    });\r\n  }\r\n};\r\n\r\n// =================== SEED SERVICE ===================\r\nexport const seedService = {\r\n  createSampleData: async () => {\r\n    try {\r\n      console.log('🔄 Criando dados de exemplo...');\r\n      \r\n      // Criar clientes de exemplo\r\n      const clients = [\r\n        {\r\n          name: 'João Silva',\r\n          email: 'joao@email.com',\r\n          phone: '(11) 99999-1111',\r\n          company: 'Silva & Associados',\r\n          address: 'Rua das Flores, 123'\r\n        },\r\n        {\r\n          name: 'Maria Santos',\r\n          email: 'maria@email.com',\r\n          phone: '(11) 99999-2222',\r\n          company: 'Santos Ltda',\r\n          address: 'Av. Principal, 456'\r\n        },\r\n        {\r\n          name: 'Pedro Oliveira',\r\n          email: 'pedro@email.com',\r\n          phone: '(11) 99999-3333',\r\n          company: 'Oliveira Corp',\r\n          address: 'Rua do Comércio, 789'\r\n        }\r\n      ];\r\n      \r\n      const clientIds = [];\r\n      for (const client of clients) {\r\n        const clientId = await clientService.create(client);\r\n        clientIds.push(clientId);\r\n      }\r\n      \r\n      // Criar assinaturas de exemplo\r\n      const subscriptions = [\r\n        {\r\n          clientId: clientIds[0],\r\n          service: 'Website Básico',\r\n          description: 'Manutenção mensal do website',\r\n          amount: 300,\r\n          billingCycle: 'monthly',\r\n          startDate: new Date('2024-01-01'),\r\n          status: 'active',\r\n          billingDay: 5\r\n        },\r\n        {\r\n          clientId: clientIds[1],\r\n          service: 'SEO Premium',\r\n          description: 'Otimização SEO completa',\r\n          amount: 800,\r\n          billingCycle: 'monthly',\r\n          startDate: new Date('2024-02-01'),\r\n          status: 'active',\r\n          billingDay: 10\r\n        },\r\n        {\r\n          clientId: clientIds[2],\r\n          service: 'Consultoria Anual',\r\n          description: 'Consultoria estratégica anual',\r\n          amount: 5000,\r\n          billingCycle: 'annual',\r\n          startDate: new Date('2024-01-15'),\r\n          status: 'active',\r\n          billingDay: 15\r\n        }\r\n      ];\r\n      \r\n      const subscriptionIds = [];\r\n      for (const subscription of subscriptions) {\r\n        const subscriptionId = await subscriptionService.create(subscription);\r\n        subscriptionIds.push(subscriptionId);\r\n      }\r\n      \r\n      // Criar algumas faturas de exemplo\r\n      const invoices = [\r\n        {\r\n          clientId: clientIds[0],\r\n          subscriptionId: subscriptionIds[0],\r\n          amount: 300,\r\n          description: 'Website Básico - Janeiro 2025',\r\n          dueDate: new Date('2025-01-05'),\r\n          status: 'paid',\r\n          month: 0,\r\n          year: 2025,\r\n          paidAt: Timestamp.now()\r\n        },\r\n        {\r\n          clientId: clientIds[1],\r\n          subscriptionId: subscriptionIds[1],\r\n          amount: 800,\r\n          description: 'SEO Premium - Janeiro 2025',\r\n          dueDate: new Date('2025-01-10'),\r\n          status: 'pending',\r\n          month: 0,\r\n          year: 2025\r\n        }\r\n      ];\r\n      \r\n      for (const invoice of invoices) {\r\n        await invoiceService.create(invoice);\r\n      }\r\n      \r\n      console.log('✅ Dados de exemplo criados com sucesso!');\r\n      return {\r\n        clients: clientIds.length,\r\n        subscriptions: subscriptionIds.length,\r\n        invoices: invoices.length\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('❌ Erro ao criar dados de exemplo:', error);\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n// =================== FUNÇÕES AUXILIARES ===================\r\n\r\n/**\r\n * Calcular próxima data de cobrança baseada no ciclo\r\n */\r\nconst calculateNextBillingDate = (startDate, billingCycle) => {\r\n  const date = new Date(startDate);\r\n  \r\n  switch (billingCycle) {\r\n    case 'monthly':\r\n      date.setMonth(date.getMonth() + 1);\r\n      break;\r\n    case 'quarterly':\r\n      date.setMonth(date.getMonth() + 3);\r\n      break;\r\n    case 'semiannual':\r\n      date.setMonth(date.getMonth() + 6);\r\n      break;\r\n    case 'annual':\r\n      date.setFullYear(date.getFullYear() + 1);\r\n      break;\r\n    default:\r\n      date.setMonth(date.getMonth() + 1);\r\n  }\r\n  \r\n  return date;\r\n};\r\n\r\n/**\r\n * Verificar se deve gerar fatura para o mês\r\n */\r\nconst shouldGenerateInvoiceForMonth = (subscription, month, year) => {\r\n  const startDate = subscription.startDate.toDate();\r\n  const currentDate = new Date(year, month, 1);\r\n  \r\n  // Assinatura deve ter iniciado\r\n  if (startDate > currentDate) {\r\n    return false;\r\n  }\r\n  \r\n  // Verificar ciclo de cobrança\r\n  const startMonth = startDate.getMonth();\r\n  \r\n  switch (subscription.billingCycle) {\r\n    case 'monthly':\r\n      return true;\r\n    case 'quarterly':\r\n      return (month - startMonth) % 3 === 0;\r\n    case 'semiannual':\r\n      return (month - startMonth) % 6 === 0;\r\n    case 'annual':\r\n      return month === startMonth;\r\n    default:\r\n      return true;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}